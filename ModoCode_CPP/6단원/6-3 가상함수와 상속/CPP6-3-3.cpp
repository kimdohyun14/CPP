// 가상 함수의 구현 원리

// 모든 함수들을 virtual로 만들어버린다면?
// 정상 작동은 하나,
// 가상 함수를 사용하게 되면 약간의 오버헤드(overhead)가 존재한다.
// 보통의 함수를 호출하는 것보다 가상 함수를 호출하는 데 걸리는 시간이 조금 더 오래 걸린다.

class Parent {
public:
	virtual void func1();
	virtual void func2();
};

class Child : public Parent {
public:
	virtual void func1();
	void func3();
};

// C++ 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해서,
// 가상 함수 테이블(virtual function table; vtable)을 만들게 된다.
// 이 테이블은 함수의 이름과 실제로 어떤 함수가 대응되는지 테이블로 저장하고 있다.

// 위의 경우 Parent와 Child 모두 가상 함수를 포함하고 있기 때문에
// 두 개 다 가상 함수 테이블을 생성하게 된다.

// Child의 func3()와 같이 비 가상함수들은 그냥 단순히 특별한 단계를 거치지 않고,
// func3()을 직접호출한다.

// 다만 가상 함수를 호출하였을 때는 그 실행 과정이 다르다.
// 가상 함수 테이블을 한 단계 더 걸쳐서, 실제로 어떤 함수를 고를지 결정하게 된다.

/*
Parent* p = Parent();
p->func1();
*/

// p는 Parent를 가리키는 포인터이므로, func1()의 정의를 Parent 클래스에서 찾아본다.
// func1()이 가상함수이므로 func1()을 직접 호출하는 것이 아닌,
// 가상 함수 테이블에서 func1()에 해당하는 함수를 찾아서 실행한다.
// 따라서 Parent::func1()을 호출하게 된다.

// 이와 같이 두 단계에 걸쳐서 함수를 호출함을 통해 소프트웨어적으로 동적 바인딩을 구현한다.
// 그래서 가상 함수를 호출하는 경우, 일반적인 함수보다 약간 더 시간이 오래 걸린다.
// 이 부분은 최적화가 매우 중요한 분야에서는 이를 감안할 필요가 있다.
// 이러한 이유로, C++에서는 멤버 함수가 디폴트로 가상함수가 되도록 설정하지 않는다.