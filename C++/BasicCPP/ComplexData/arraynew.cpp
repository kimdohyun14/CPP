#include <iostream>
using namespace std;
int main()
{
	double* p3 = new double[3];

	// C와 C++가 배열을 구현할 때, 내부적으로는 포인터를 사용하기 때문에
	// 이러한 접근이 가능하다.
	p3[0] = 0.2; // p3을 배열 이름처럼 취급한다.
	p3[1] = 0.5; 
	p3[2] = 0.8;
	cout << "p3[1] = " << p3[1] << endl;
	p3 = p3 + 1; // 포인터를 증가!! (배열 이름이면 틀린 표현, 포인터면 맞는 표현이다)
	cout << "p3[0]이 " << p3[0] << "이고, ";
	cout << "p3[1]이 " << p3[1] << "이다.\n";
	p3 = p3 - 1; // 다시 시작 위치를 지시한다.
	delete[] p3; // 배열 메모리를 해제한다.
	return 0;
}

/* new를 사용한 동적 배열의 생성

- 일반적인 배열 선언은 프로그램이 컴파일될 때 배열을 위한 메모리가 대입된다.
- 이 방식을 정적 바인딩이라고 한다.
- 배열이 컴파일 시간에 생성된다는 것을 뜻한다.

- new 를 사용한 방법은 프로그램을 실행하는 동안에 배열의 크기를 결정할 수 있다.
- 이 방식을 동적 바인딩이라고 한다.
- 배열이 런타임에 생성된다는 것을 뜻한다.

- new 연산자는 그 블록의 첫 번째 원소의 주소를 리턴한다.

- new 로 대입하지 않는 메모리는 delete 로 해제하지 않는다.
- 같은 메모리 블록을 연달아 두 번 delete 로 해제하지 않는다.
- new [] 로 메모리를 대입한 경우에는 delete [] 로 해제한다.
- new 를 대괄호 없이 사용했으면 delete 도 대괄호 없이 사용한다.
- 널 포인터에는 delete 를 사용하는 것이 안전하다. (아무 일도 일어나지 않기 때문에)
*/