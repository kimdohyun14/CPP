#include <iostream>
#include <cstring>
using namespace std;

char* getname(void); // 함수 원형
int main()
{
	// new, delete를 서로 다른 함수에서 사용하는 것은 좋은 생각은 아니다.
	// delete를 사용하는 일을 잊어버리기 쉽기 때문
	char* name;
	name = getname();
	cout << (int*)name << ": " << name << endl;
	delete[] name;

	name = getname();
	cout << (int*)name << ": " << name << endl;
	delete[] name;
	return 0;
}

char* getname()
{
	char temp[80];
	cout << "이름을 입력하세요: ";
	cin >> temp;
	char* pn = new char[strlen(temp) + 1];
	strcpy(pn, temp); // 문자열을 더 작은 공간으로 복사한다.
	return pn; // 함수가 종료될 때 임시 배열인 temp는 소멸한다!
}

/*
데이터를 저장해 두기 위한 메모리를, 대입하는 방법에 따라
자동 공간, 정적 공간, 동적 공간으로 구분한다.

동적 공간과 자유 공간 또는 힙(heap)이라고도 부른다.
각각의 메모리 공간에 대입된 데이터 객체는 수명이 서로 다르다.

# 자동 변수(Automatic variable)
- 자신이 정의되어 있는 함수가 호출되는 순간에 자동으로 생겨나 그 함수가 종료되는 시점까지만 존재한다는 공간
- temp가 그런 용도                                                                                                                         
- 자신들을 포함하고 있는 블록 안에서만 유효하다.
- 자동 변수는 스택에 저장된다.
- 메모리상의 스택에 그 값이 순차적으로 저장되고, 역순으로 해제되는 것을 의미한다.
- 스택은 프로그램이 실행하는 동안 늘었다 줄었다를 반복한다.

# 정적 공간(Static storage)
- 프로그램이 실행되는 동안에 지속적으로 존재하는 공간이다.
- 함수의 외부에서 변수를 정의하는 것
- 변수를 선언할 때 static 이라는 키워드를 붙이는 것

# 동적 공간(Dynamic storage)
- new와 delete 연산자는 보다 융통성 있는 방법을 제공한다.
- 자유 공간(free store)이라 부르는 메모리 풀(memory pool)을 관리한다.
- 데이터의 수명은 프로그램의 수명이나 함수의 수명에 얽매이지 않는다.
- new 와 delete 를 함께 사용하면 일반 변수를 사용할 때보다 메모리에 대해 더 강력한 제어권을 가질 수 있다.
- new 와 delete 의 상호작용으로 여유 공간을 확보할 수 있고, 더 복잡한 메모리 대입 요청을 처리할 수 있다.

# 스택, 힙, 메모리 누수
new 연산자로 자유 공간(힙)에 변수를 생성한 후 delete를 사용하여 이를 해제하지 않으면?
자유 공간에 생존하고 있는 변수나 데이터 객체에 접근할 수 있는 방도가 전혀 없다.
변수나 데이터 객체가 저장되어 있는 메모리 위치를 지시하는 포인터가 이미 사라졌기 때문에.
이것을 우리는 메모리 누수(memory leak)이라고 한다.

누수된 메모리는 프로그램을 실행하는 동안 내내 사용할 수 없게 된다.
=> 메모리가 대입은 되었으나 접근이 불가능하다.

메모리 누수가 매우 심각하여 애플리케이션에 할애된 메모리를 모두 소진할 수도 있다.
그 결과 메모리 부족으로 프로그램이 먹통이 된다.
메모리 누수는 동일한 메모리 공간에서 운영되는 운영 체제나 다른 애플리케이션에도 부정적인 영향을 끼쳐,
결국 그들을 차례대로 망가뜨리기도 한다.

new 와 delete 연산자를 가능한 가깝게 결합하여 사용하는 습관을 들여야 한다.
자유 공간에 동적으로 변수나 데이터 객체를 대입하자마자 delete 연산자를 사용할 계획을 서둘러야 한다.
*/