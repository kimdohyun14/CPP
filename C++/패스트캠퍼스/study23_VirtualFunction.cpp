#include <iostream>
using namespace std;

// 가상 함수

   /* 가상 함수(Virtual Function)란 자식 클래스에서 재정의할 수 있는 멤버 함수이다.
      virtual 키워드를 이용해 가상 함수를 선언할 수 있으며 자식 클래스에서 가상 함수를 재정의하면 
      재정의된 멤버 함수 또한 가상 함수로 분류된다.*/


// 동적 바인딩

   /* C++은 특정한 함수를 호출할 때 해당 함수의 루틴이 기록된 메모리 주소를 알아야 한다.
      특정한 함수를 호출하는 소스코드에서 실제로 함수가 정의된 메모리 공간을 찾기 위해서는 바인딩(Binding)과정이 필요하다. 
   
      일반적으로 함수의 호출은 컴파일 시기에 고정된 메모리 주소를 이용한다. 이러한 방식을 정적 바인딩(Static Binding)이라고 하는데,
      C++의 일반적인 멤버 함수는 모두 이러한 정적 바인딩을 사용한다.
   
      다만 가상 함수는 프로그램이 실핼될 때 객체를 결정한다는 점에서 컴파일 시간에 객체를 특정할 수 없다.
      그래서 가상 함수는 실행 시간 때 올바른 함수가 실행될 수 있도록 동적 바인딩(Dynamic Binding)을 사용한다. */

// 가상 함수

   /* C++ 컴파일러는 가상 함수 테이블(Virtual Function Table)을 이용해 가상 함수를 다루게 된다.
      C++ 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 멤버를 하나씩 저장한다.

      가상 함수 테이블에는 특정한 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장된다.
      따라서 가상 함수를 호출하면 C++ 프로그램은 가상 함수 테이블에 접근하여 자신이 필요한 함수의 주소를 찾아 호출하게 된다.

      이러한 과정은 말 그대로 동적 바인딩을 통해 이루어지므로 컴퓨팅 리소스를 소모하게 된다.
      그래서 C++은 기본적으로 정적 바인딩을 채택하고 있다.

      따라서 자식 클래스가 재정의할 가능성이 있는 멤버 함수들은 가상 함수로 선언하는 것이 좋다. */

class A
{
public:
    virtual void show() { cout << "A클래스" << endl; }
};

class B : public A
{
public:
    virtual void show() { cout << "B클래스" << endl; }
};

int main()
{
    A* p;
    A a;
    B b;
    p = &a; p->show();
    p = &b; p->show();
    return 0;
}