#include <iostream>
using namespace std;

// C++의 다형성 기법

/* 다형성(Polymorphism)이란 여러 개의 서로 다른 객체가 동일한 기능을 서로 다른 방법으로 처리할 수 있는 기능을 의미한다.
   예를 들어 게임 프로그램에서 칼, 대포, 총 등의 무기들은 공통적으로 '공격'이라는 동일한 기능을 수행할 수 있다. */

/*
무기 객체
attack()

칼 객체    대포 객체    총 객체
attack()   attack()     attack()

무기 객체에서 attack() 함수를 실질적으로 구현할 필요가 없다.
이럴 때 무기 객체를 추상 클래스(Abstract Class)로 구현하면 효과적으로 설계할 수 있다.
*/

// 자식 클래스에서 오버라이딩의 문제점

/* 자식 클래스에서 멤버 함수를 재정의하여 사용하는 것은 일반적으로 정상적으로 동작한다.
   하지만 포인터 변수로 객체에 접근할 때는 예상치 못한 결과가 발생할 수 있다. 
   
   C++ 컴파일러는 포인터 변수가 가리키고 있는 변수의 타입을 기준으로 함수를 호출하지 않고,
   포인터의 타입을 기준으로 함수를 호출한다. 따라서 A라는 객체를 가리키는 포인터 변수는 A객체의 멤버 함수만을 호출할 수 있다. */


// 일반적인 함수의 정적 바인딩 문제점
// 추상 클래스는 이러한 문제 때문에 만들어졌다. 동적 바인딩을 사용함.
class A
{
public:
    void show() { cout << "A 클래스" << endl; }
};

class B : public A
{
    void show() { cout << "B 클래스" << endl; }
};

int main()
{
    A* p; // A라는 객체를 가리키는 포인터 변수 p는 A객체의 멤버 함수만을 호출할 수 있다.
    A a;
    B b;
    p = &a; p->show(); // A객체를 가리킨다.
    p = &b; p->show(); // B객체를 가리킨다.
    return 0;
}